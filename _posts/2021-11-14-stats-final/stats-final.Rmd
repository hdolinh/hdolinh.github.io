---
title: "Environmental Statistics Final"
description: |
  A short description of the post.
author:
  - name: Halina Do-Linh
date: 11-14-2021
output:
  distill::distill_article:
    self_contained: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r loading packages, include=FALSE}
library(tidyverse)
library(here)
library(lintr)
library(janitor)
library(lubridate)
library(gt)
library(readr)
library(ggplot2)
library(modelr)
library(knitr)
library(broom)
library(tsibble)

options(scipen = 999) # disable scientific notation
```

**NO TIME SERIES BECAUSE COULD NOT GET INTO DATE OBJECT**


# Technical Blog Guidelines

**Technical blog post [Due date: 12/2, 5pm]**

This blog post is a write up summarizing in text and with figures and/or tables your question, the data you have collected, your analysis plan, and your results. Your target audience should be other quantitative scientists and practitioners familiar with the basics of statistics and data science, but not necessarily experts in environmental science or the details of the methods studied in this course.

**Please email me your blog post in PDF format and as a live link by 5pm on December 2.**

Some guidelines for the blog post:

-   3-5 pages in length, including figures, tables, captions, and references list
-   1-3 tables or figures, each carefully labeled and captioned so that they are easily interpretable
-   Include scientific references when applicable
-   Include links to the underlying data you use. If your data cannot be shared publicly, note this in a short "data availability" statement at the end of your post.
-   [Recommended, but optional] If you can, include a link to a repository with your replication code. I will not evaluate your code as part of your grade, but this is good practice for reproducibility and transparency and will make your blog post more exciting to the outside world.

# General Guidelines

-   Motivate your question.

    -   Why is this important?

    -   Is there existing evidence on this question?

    -    If so, why is it inconclusive? If not, why not?

-   Describe your data.

    -    Where did you access it? What are its spatial and temporal features?

    -   What are its limitations?

    -   What do you know about the sampling strategy and what biases that may introduce?

    -   If helpful, you can use a histogram, scatterplot, or summary statistics table to describe your data.

-   Clearly describe your analysis plan.

    -   What is your analysis plan?

    -   Why did you choose this analysis, given your data and question?

    -   What are the limitations?

-   Summarize your results visually and in words.

    -   Show us your results in figure(s) and/or table(s) that are carefully labeled and captioned.

    -   Describe in the text (and orally when presenting) what you found, and how these results either do or do not help you answer your question.
    
## Data Setup

### Import Data

I received data from Dr. Scott Jasechko on private wells in California and AK (TBD on what AK is). 

```{r}
wells <- read_csv(here::here("_posts", "2021-11-14-stats-final", "data", "08_CA_AK.csv"))
```


```{r}
wells_AK <- wells %>% 
  filter(str_detect(WellID, pattern = "AK")) # AK wells are not associated with any Counties in CA, so can confirm we should remove
```

Here I have made my tidy dat

```{r, tidy}
wells_clean <- wells %>% 
  janitor::clean_names()
```


```{r, selecting columns of interest}
wells_county_depth <- wells_clean %>% 
  select("well_id", "county", "purpose_5", "date_completed", "activity_type", "depth_m")
```

```{r, looking at what CA counties there are}
unique(wells_county_depth$county)
```

**Added region codes to counties:**

```{r, added region codes and filtered out NA / out of scope (i.e. AK)}
region1 <- c("Butte", "Colusa", "El Dorado", "Glenn", "Lassen", "Modoc", "Nevada", "Placer", "Plumas", "Sacramento", "Shasta", "Sierra", "Siskiyou", "Sutter", "Tehama", "Yolo", "Yuba")
region1_code <- 1

region2 <- c("Del Norte", "Humboldt", "Lake", "Mendocino", "Napa", "Sonoma", "Trinity")
region2_code <- 2

region3 <- c("Alameda", "Contra Costa", "Marin", "San Francisco", "San Mateo", "Santa Clara", "Solano")
region3_code <- 3

region4 <- c("Alpine", "Amador", "Calaveras", "Madera", "Mariposa", "Merced", "Mono", "San Joaquin", "Stanislaus", "Tuolumne")
region4_code <- 4

region5 <- c("Monterey", "San Benito", "San Luis Obispo", "Santa Barbara", "Santa Cruz", "Ventura")
region5_code <- 5

region6 <- c("Fresno", "Inyo", "Kern", "Kings", "Tulare")
region6_code <- 6

region7 <- c("Riverside", "San Bernardino")
region7_code <- 7

region8 <- "Los Angeles"
region8_code <- 8

region9 <- "Orange"
region9_code <- 9

region10<- c("Imperial", "San Diego")
region10_code <- 10

wells_region <- wells_county_depth %>% 
  mutate(region_code = case_when(county %in% region1 ~ region1_code,
                                 county %in% region2 ~ region2_code,
                                 county %in% region3 ~ region3_code,
                                 county %in% region4 ~ region4_code,
                                 county %in% region5 ~ region5_code,
                                 county %in% region6 ~ region6_code,
                                 county %in% region7 ~ region7_code,
                                 county %in% region8 ~ region8_code,
                                 county %in% region9 ~ region9_code,
                                 county %in% region10 ~ region10_code,
                                 TRUE ~ 0)) %>% 
  filter(str_detect(well_id, pattern = "CA")) %>% # removed wells not in CA
  filter(depth_m > -1) # removed NA well depths that Scott categorized as -1
```

**Plot to see distribution of well depth (m). Had to take the log of well depth:**

```{r, distribution of well depth (m)}
log_depth_m <- log(wells_region$depth_m)

depth_hist <- ggplot(data = wells_region, aes(log_depth_m)) +
  geom_histogram()

depth_hist
```

**Plot of region:**

```{r, distribution of regions}
# to color cannot use "color" in histogram, need to use "fill"
# region_code originally has class numeric but needs to be class factor to fill

region_hist <- ggplot(data = wells_region, aes(x = region_code, fill = as.factor(region_code))) + 
  geom_histogram() 

region_hist
```


**Need to count how many wells were completed by year**

```{r}
well_count_year <- wells_region[!is.na(strptime(wells_region$date_completed, format = c("%m/%d/%y", "%m/%d/%Y", "%m/%d/%y HMS"))),]

well_count_year <- well_count_year %>% 
  mutate(date_completed = lubridate::parse_date_time(date_completed, orders = c("mdy", "mdy HMS", "mdY"))) %>% 
  mutate(year_completed = lubridate::year(date_completed)) %>% 
  filter(year_completed >= 1900 & year_completed <= 2021) %>% 
  group_by(year_completed) %>% 
  count()

ggplot(data = well_count_year, aes(x = year_completed, y = n)) +
  geom_line()
  
```


**Count how many wells were completed each year and in each region**

```{r}
well_count_year_region <- wells_region[!is.na(strptime(wells_region$date_completed, format = c("%m/%d/%y", "%m/%d/%Y", "%m/%d/%y HMS"))),]

well_count_year_region <- well_count_year_region %>% 
  mutate(date_completed = lubridate::parse_date_time(date_completed, orders = c("mdy", "mdy HMS", "mdY"))) %>% 
  mutate(year_completed = lubridate::year(date_completed)) %>% 
  filter(year_completed >= 1900 & year_completed <= 2021) %>% 
  group_by(region_code, year_completed) %>% 
  count()

ggplot(data = well_count_year_region, aes(x = year_completed, y = n, color = as.factor(region_code))) +
  geom_point()
```
**Create North/South Region so that you have a categorical variable with only two levels as opposed to 10**

- Plot date (year only), mean of well depth(m), and color by north/south region
- Need to test if this is significant! 

```{r}
norcal <- c(1, 2, 3, 4, 5)
norcal_code <- "north"

socal <- c(6, 7, 8, 9, 10)
socal_code <- "south"

region_north_south <- wells_region %>% 
  mutate(north_south = case_when(region_code %in% norcal ~ norcal_code,
                                 region_code %in% socal ~ socal_code,
                                 TRUE ~ "NA")) %>% 
  mutate(date_completed = lubridate::parse_date_time(date_completed, orders = c("mdy", "mdy HMS", "mdY"))) %>% 
  mutate(year_completed = lubridate::year(date_completed)) %>% 
  filter(year_completed >= 1900 & year_completed <= 2021) %>% 
  mutate(north_south = as.factor(north_south)) %>% # make north_south a factor variable
  group_by(year_completed, north_south) %>% 
  mutate(mean_depth_m = mean(depth_m)) # yearly averages 

mod <- lm(mean_depth_m ~ year_completed + north_south, data = region_north_south)

ggplot(data = region_north_south, aes(x = year_completed, y = mean_depth_m,  color = north_south)) +
  geom_point() +
  geom_line(data = augment(mod), aes(y = .fitted, color = north_south)) +
  labs(x = "Year well was completed",
       y = "Yearly average well depth (m)") +
  scale_colour_discrete("North South Region")
  
```


```{r}

mod_interaction <- lm(mean_depth_m ~ year_completed + north_south + year_completed:north_south, data = region_north_south) 
summary(mod_interaction)

```


```{r}
ggplot(region_north_south, aes(y = mean_depth_m, x = year_completed, color = north_south)) + 
  geom_point() + 
  geom_smooth(method = "lm", se = FALSE)
```


```{r}
mod_interaction <- lm(mean_depth_m ~ year_completed + north_south + year_completed:north_south, data = region_north_south) 

region_north_south %>% 
  ggplot(aes(x = year_completed, y = mean_depth_m, color = north_south)) +
  geom_point() +
  geom_line(data = augment(mod_interaction), aes(y = .fitted, color = north_south)) 
```


```{r}
# no interaction
mod <- lm(mean_depth_m ~ year_completed + north_south, data = region_north_south)
AdjR2 <- summary(mod)$adj.r.squared
print(AdjR2)

# with the interaction
mod_interaction <- lm(mean_depth_m ~ year_completed + north_south + year_completed:north_south, data = region_north_south) 
AdjR2_int <- summary(mod_interaction)$adj.r.squared
print(AdjR2_int)
```
**Interpretation: Since the adjusted $R^2$ value increased slightly, we conclude that the interaction model.....improves the model fit a little (but not meaningfully?). This indicates that the north_south region variable are adding value to the model. **


**HYPOTHESIS TESTING**

```{r}

```



**Plot of Wells Region 1 and Depth**

```{r}
well_region_1 <- wells_region[!is.na(strptime(wells_region$date_completed, format = c("%m/%d/%y", "%m/%d/%Y", "%m/%d/%y HMS"))),]

well_region_1 <- wells_region %>% 
  filter(region_code == 1) %>% 
  mutate(date_completed = lubridate::parse_date_time(date_completed, orders = c("mdy", "mdy HMS", "mdY"))) %>% 
  filter(date_completed >= as.POSIXct("1900-01-01") & date_completed < as.POSIXct("2021-11-26"))

ggplot(data = well_region_1, aes(x = date_completed, y = depth_m)) +
  geom_line()
```


**Plot time**

```{r}
# found there are some dates with HMY format using table(wells-region$date_completed)

wells_time <- wells_region %>% 
  select(well_id, date_completed) %>% 
  mutate(date_completed = na.omit())
  mutate(date_completed = lubridate::guess_formats(date_completed, orders = "mdy"))

wells_time <- wells_region %>%
  mutate(date_completed = lubridate::mdY(date_completed))

time_hist <- ggplot(data = wells_region, aes(log_depth_m)) +
  geom_histogram()

time_hist

wells_time2 <- wells_region %>% 
  mutate(date_completed = lubridate::mdy(date_completed))

wells_time3 <- wells_region %>% 
  group_by(date_completed) %>% 
  count()


wells_valid_dates <- wells_region[!is.na(strptime(wells_region$date_completed, format = c("%m/%d/%y", "%m/%d/%Y", "%m/%d/%y HMS"))),]


wells_valid_dates <- wells_valid_dates %>% 
  mutate(date_completed = lubridate::parse_date_time(date_completed, orders = c("mdy", "mdy HMS", "mdY"))) %>% 
  filter(date_completed >= as.POSIXct("1900-01-01") & date_completed < as.POSIXct("2021-11-26"))



```

```{r}
ggplot(data = wells_valid_dates, aes(x = date_completed, y = depth_m, color = region_code)) + 
  geom_point(alpha = 0.3)

```


```{r}
wells_valid_dates %>% 
  summarize(wells_depth = cor(date_completed, depth_m)) %>% 
  gt()
```


```{r}
lm(depth_m ~ date_completed, data = wells_valid_dates) %>%
  summary()
```

```{r}
ggplot(data = wells_valid_dates, aes(x = region_code, y = depth_m)) +
   geom_point()
```


```{r}
wells_region_1_10 <- wells_valid_dates %>% 
  filter(region_code %in% c(1, 10))

wells_region_1_10 <- wells_region_1_10 %>% mutate(region_code = as.factor(region_code)) # Recall, we do this to ensure our year variable is treated as a categorical variable

mod <- lm(depth_m ~ date_completed + region_code, data = wells_region_1_10)

wells_region_1_10 %>% 
  ggplot(aes(x = date_completed, y = depth_m, color = region_code)) +
  geom_point() +
  geom_line(data = augment(mod), aes(y = .fitted, color = region_code)) + 
  labs(x = "Date Completed",
       y = "Depth of Wells (m)") +
  scale_colour_discrete("Region Code")
```



```{r, deleted}
# wells_time_only_year <- wells_region %>% 
#   mutate(date_completed = na.omit(date_completed)
#   mutate(date_completed = format(date_completed, format = "%m/%d/%Y")) %>% 
#   group_by(date_completed) %>% 
#   count() %>% 
#   na.omit
#   mutate(date_completed = lubridate::mdy(date_completed))
# 
# wells_time_only_year <- wells_region %>% 
#   group_by(date_completed) %>% 
#   count()
# 
# wells_time_na <- wells_region %>% 
#   drop_na(date_completed) %>% 
#   mutate(date_completed = lubridate::parse_date_time(date_completed, c("mdy", "mdy HMS", "mdY")))
# 
# # wells_valid_dates <- wells_valid_dates %>% 
# #   group_by(date_completed) %>% 
# #   count()
```



-   What might you do next?

    -   One short analysis cannot fully answer an interesting scientific question.

    -   If you had time to collect more data or conduct more analysis, what would help you answer this question better?

Distill is a publication format for scientific and technical writing, native to the web.

Learn more about using Distill at <https://rstudio.github.io/distill>.
